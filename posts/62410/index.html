<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: 待读论文 | Yan 的杂物志_个人主页分享</title><meta name="author" content="Yan.xie"><meta name="copyright" content="Yan.xie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于深度学习的语音合成技术综述，全面介绍从文本分析到声码器的实现方法及最新研究进展。">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读_语音合成综述">
<meta property="og:url" content="http://xyan666.com/posts/62410/index.html">
<meta property="og:site_name" content="Yan 的杂物志_个人主页分享">
<meta property="og:description" content="基于深度学习的语音合成技术综述，全面介绍从文本分析到声码器的实现方法及最新研究进展。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://xyan666.com/img/blog_logo.png">
<meta property="article:published_time" content="2022-01-15T00:00:00.000Z">
<meta property="article:modified_time" content="2025-04-04T00:00:00.000Z">
<meta property="article:author" content="Yan.xie">
<meta property="article:tag" content="论文阅读">
<meta property="article:tag" content="语音">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xyan666.com/img/blog_logo.png"><link rel="shortcut icon" href="/img/blog_logo.png"><link rel="canonical" href="http://xyan666.com/posts/62410/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: 待读论文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-04 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="referrer" content="no-referrer"/><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/blog_logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">864</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">182</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Yan 的杂物志_个人主页分享"><span class="site-name">Yan 的杂物志_个人主页分享</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">论文阅读_语音合成综述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-01-15T00:00:00.000Z" title="Created 2022-01-15 00:00:00">2022-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-04T00:00:00.000Z" title="Updated 2025-04-04 00:00:00">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Note/">2_Note</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Note/0-Technic/">0_Technic</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Note/0-Technic/2-%E7%AE%97%E6%B3%95/">2_算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Note/0-Technic/2-%E7%AE%97%E6%B3%95/1-%E9%9F%B3%E9%A2%91/">1_音频</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>36min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="论文阅读_语音合成综述"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="基本信息">基本信息</h2>
<p>题目：Survey on Neural Speech Syntheis</p>
<p>论文地址：https://arxiv.org/abs/2106.15561</p>
<p>上传时间：2021 年 1 月</p>
<p>全文翻译：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42721167/article/details/118684294">论文学习：A
Survey on Neural Speech Synthesis</a></p>
<h2 id="阅读体会">阅读体会</h2>
<p>比较全面介绍用<strong>深度学习</strong>实现<strong>语音合成</strong>的<strong>综述性</strong>论文。论文整体
63 页，其中正文 37 页，参考 TTS 相关论文 400
多篇。本文并不打算对论文逐句翻译，只列出重点，作为个人阅读笔记，同时加入笔者的一些注释。</p>
<h2 id="摘要">摘要</h2>
<p>近年来基于神经网络的深度学习算法大大提升了语音合成的质量，这篇文章集学术研究和工业应用于一体，是一篇综述性的文档，它包含语音合成的几个重要组成部分：<strong>文本分析、声学模型和声码器</strong>；涉及热门主题，比如：快速
TTS，使用更少资源训练等等；还总结了 TTS
相关资料（工具和数据），最后讨论了 TTS 未来的发展方向。</p>
<h2 id="介绍">1. 介绍</h2>
<p>TTS
主要指的是把文本转换成语音输出，它是一个由来已久的课题，涉及：<strong>语言学、声学、数据信号处理、机器学习</strong>等领域。这几年深度学习使
TTS 效果有了显著提升，这篇论文是对深度学习 TTS 的综述。</p>
<h3 id="tts-历史">1.1 TTS 历史</h3>
<p>（从 12
世纪开始……此处省略）早期的计算机语音合成包括：频谱参数合成、音素合成、连接合成等方法；之后基于统计的机器学习算法，来预测<strong>频谱、基频、长度</strong>等合成参数；从<strong>2010
年之后，基于神经网络的语音合成占据主导地位</strong>，实现了更好的合成效果。</p>
<ul>
<li><p>频谱参数合成<br />
算法模拟嘴唇、舌头、声门和声道的动作产生语音。理论上，它模拟了人类发音方法，是最有效的合成法，而实际上很难采集各个参数的数据，因此该方法效果往往比后面几种方法效果差（笔者注：发音像“机器人”一样的“金属音”）。</p></li>
<li><p>共振峰合成<br />
基于一系列规则控制录波器模型产生语音，规则用于模拟共振峰及其谐波的特征，它由合成模型和声学模型组成，通过一系列参数控制，如基频、音色、噪音等。它合成出的音质较高，占用资源较低，使用于嵌入式系统，且不依赖大量的语料库，但相对来说合成效果不够自然，这是由于很难针对自然度描述规则。</p></li>
<li><p>基于连接的合成<br />
基于连接的方法依赖存储在数据中大量的语音片断，它包括从整句到音节的播音员录音，在合成过程中，算法搜索最值语音片断，通过连接这些片断产生合成语音，它产生的语音具有较高的读性，更接近播音员的音色，但需要录制大时音频，且在情绪、自然度、韵律、流畅度方面较差。</p></li>
<li><p>基于统计的合成<br />
基于统计的合成简称 SPSS（statistical parametric speech
synthesis），与基于连接合成不同的是，它生成声数参数，然后通过利过算法利用这些参数复原语音，它通常由文本分析、声学模型（参数预测）、声码器三部分组成，如图
1
所示（三部分后面详述）。该类模型的优点是：合成效果更自然、灵活性更高（可调节参数）；较低的资源占用。它的缺点的：合成的声音可能带有噪音，听起来有些像机器人，而非自然的人声。</p></li>
</ul>
<p><img
src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" /></p>
<ul>
<li>基于神经网络的合成<br />
随着神经网络技术发展，神经网络被引入了 SPSS，作为其中的声学模型替代 HMM
统计模型预测参数，后来又发展出了直接用音素生成音频的模型，WaveNet
被视为首例神经网络 TTS 模型，后来又发现出了 end-to-end
模型，将文字直接转换成音频。相对于之前的模型，它在自然度和智能性都有更高水平，并且更少依赖人工预处理和特征工程。</li>
</ul>
<h3 id="文章组织方式">1.2 文章组织方式</h3>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211202114451.png"
alt="Pasted image 20211202114451.png" />
<figcaption aria-hidden="true">Pasted image
20211202114451.png</figcaption>
</figure>
<p>论文主要包含两大主题：TTS 的主要组成、TTS 高级主题。</p>
<ul>
<li>第一部分简单介绍</li>
<li>第二部分介绍了 TTS 主组由上图的三部分组成：文本分析（Text
Analysis）模块将文本序列转换为语言特征，声学模型（Acoustic
Model）从语言特征生成声学特征，声码器（Vocoder）从声学特征合成波形。及其模型的实现。</li>
<li>第三部分介绍一些前沿问题，如：提升模型速度，减少资源占用，用少量数据更训练效果更好的模型，提升鲁邦性解决丢音、重复等问题，加强情感表达，通过不量训练模拟某人语音等。</li>
<li>第四部分列出了开源的代码和语料库资源。</li>
<li>第五部分总结展望。</li>
</ul>
<h2 id="主要组成部分">2. 主要组成部分</h2>
<p>主要介绍上图中三部分的神经网络实现，</p>
<h3 id="主要分类">2.1 主要分类</h3>
<p>一般将语言合成分成文本分析、声学模型、声码器三部分，以及 end-to-end
模型。文本分析把文本转换成语言学特征，声学模型把语言学特征转换成声学特征，声码器将声学特征转换成音频。而
end-to-end
模型直接将文本转换成音频。也可将其中的几个步骤放在一个模型中，如图
所示：</p>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211204145259.png"
alt="Pasted image 20211204145259.png" />
<figcaption aria-hidden="true">Pasted image
20211204145259.png</figcaption>
</figure>
<h3 id="文本分析">2.2 文本分析</h3>
<p>文本分析将文本转换成包含语音和韵律的特征。在统计参数合成中，文本分析用于提取语言特征向量序列，并且包含诸如文本规范、短语切分、标注成份，韵律预测，字符到音素转换等功能。尽管
end-to-end
模型，大幅简化了文本分析功能，但一般情况下还是需要做一些规范化和字符到音素映射的工具。文本分析一般包含以下步骤：</p>
<ul>
<li>文本规范化：将 "1989", "Jan 24"
转换成对应文本，规范化一般基于规则；也有一些神经网络模型利用序列处理解决这一问题；之前有人研究结合规则和神经网络来提升效果。</li>
<li>短语切分：像中文需要将字分成词再进行下一步处理。</li>
<li>标注成分：标句子成份，如：名词、动词……</li>
<li>韵律预测：韵律包含节奏、重音和语调，它们与时长、音量和音高相对应，这些因素在言语交际中起着重要作用，对于不同语言也有不同处理，对于中文，韵律词、韵律短语和语调短语构成了韵律树三层结构，利用
RNN, CRF, Self-Attention 等方法来解决该问题。</li>
<li>字符到音素转换：将字符转换成音标（拼音），主要通过查表方法实现，对于英文这种字母单音，字典不能涵盖所有单词，因此需要模型或规则辅助转换，对于中文，除字典以外，也需要根据上下文处理多音字，这也需要用模型消歧。</li>
</ul>
<p>综上，文本分析需要从音素、音节、词、短语和句子等不同层面来构建语言特征。文本分析与神经网络有很多结合，比如用一个神经网络实现文本分析的任务。韵律对语音的自然度有很大影响，在神经网络模型简化模型的基础上，也将音高、时长、断句、呼吸、停顿等因素加入了编码器的上层。另外，还有一些方法来支持韵律特征：(1)
从语音中学习韵律规则; (2) 利用无监督数据学习韵律生成预测训练模型 (3)
使用图网络来结合语法信息。</p>
<h3 id="声学模型">2.3 声学模型</h3>
<p>声学模型将语言学特征转换成声学特征，具体实包括在 SPSS 中使用 HMM 或
DNN 实现的静态参数模型；基于 encoder-attention-decoder
框架的序列模型；以及最新的用于并行生成器的前馈网络。可以将声学模型分为两种：SPSS
中的声学模型，根据语言特征预测 MGC、BAP 和 F0 等声学特征；以及基于神经的
end-to-end 模型，其根据音素或字符来预测声学特征。</p>
<h4 id="spss-中的声学模型">2.3.1 SPSS 中的声学模型</h4>
<p>这类模型的研发由以下几个因素驱动：1)
可采用更多的上下文信息作为输入；2) 可以考虑到输出帧之间的相关性；3)
处理语言特征到声学特征的映射是一对多的情况。</p>
<ul>
<li><p>HMM 隐马尔模型可用于生成语音参数，与之前的拼接方法相对，HMM
在改变说话人、情感、风格等方面比较灵活，它的主要缺点是音质较少，原因是：1)
声学模型精度不高，过于平滑缺乏细节；2) HMM
模型能力的不足使声音编码技术受限。</p></li>
<li><p>DNN 深度神经网络模型提升的合成的质量；LSTM
类模型又考虑了远距离上下文的影响；后续还有使用 CBHG，GAN，基于 Attention
的循环神经网络来进一步改善声学模型的品质。</p></li>
</ul>
<h4 id="end-to-end-的声数模型">2.3.2 End-to-end 的声数模型</h4>
<p>end-to-end 的声学模型对于传统的 SPSS 模型，有以下有事：1)
不需要对齐语言特征和声学特征，简化了预处理；2)
为了提高性能，输入的语言特征被简化为字符或音素序列，输出声学特征从低维的
MGC 向高维的 Mel 谱图甚至更高维线性谱图转变。</p>
<ul>
<li><p>基于 RNN 的模型（Tracotron 系列）</p>
<p>Tacotron 利用注意力框架，输入作为字符线性谱输出，并使用 Griffin-Lim
算法来生成波形。Tacotron2 使用附加的 WaveNet
模型来生成梅尔谱图并生成波形。Tacotron 2 比以往的拼接 TTS、参数
TTS、神经 TTS 的语音质量有了很大的提高。</p>
<p>后来有很多工作从不同方面对 Tacotron 进行了改进：1)
采用参考编码器和风格符号来增强语音合成的表现力，2)
去掉注意机制，用时间长预测实现自回归，3) 将自回归生成改为非自回归，4)
建立端到端的文本生成波形模型。</p></li>
<li><p>基于 CNN 的模型（DeepVoice 系列）</p>
<p>DeepVoice 用卷积神经网络优化了 SPSS
系统。通过神经网络获取语言特征后，基于 WaveNet
的声码器生成波形。DeepVoice 2 通过改进的网络结构和支持多说话人来增强
DeepVoice。它还采用了 Tacotron+WaveNet 的 pipeline，首用 Taco tron
生成线谱图，然后使用 WaveNet 生成波形。DeepVoice 3
利用全卷积网络结构进行语音合成，它可以从字符生成梅尔谱图，并可扩展到多说话人数据集。并使用了更紧凑的序列到序列模型，跳过了生成语言特征的步骤。</p>
<p>之后，ParanNet
是完全基于卷积的非自回归模型，可以加快梅尔谱图的生成速度，并获得较好的语音质量。DCTTS
与 Tacotron 共享类似的 pipeline，并利用基于完全卷积的 attention
网络从字符序列生成梅尔谱图。它们使用超分辨率网络获得线性谱图，并使用
Griffin-Lim 合成波形。</p></li>
<li><p>基于 Transformer 的模型（FastSpeech 系列）</p>
<p>TransformerTTS 利用 attention 框架从音素产生梅尔图谱。之前基于 RNN 的
attention 网络主要存在两个问题：1)
编码器和解码器不能并行训练，编码器不能并行预测，影响了使用效率；2) RNN
对于长序列的依赖关系建模效果较差。TransformerTTS 采用了 Transformer
的基本模型结构，并吸收了 Tacotron2
中解码器、前网/后网和预测停止符号的设计。它的音质与 Taco tron2
相当，但训练时间更短。Transformer 由于并行计算而并不很稳定，又出现了
MultiSpeech
通过编码器归一化、解码器瓶颈和对角注意约束等方式，提高了注意机制的健壮性，而
RobuTrans 利用持续时间预测来增强自回归的健壮性。</p>
<p>前面所述模型都使用自回归的生成器有以下问题：1) 预测速度慢，2)
健壮性问题：由于文本与梅尔谱图之间的对齐不准确造成的跳词、重复问题。FastSpeech
提取了以下解决办法：1) 用前馈的 Transformer 网络提升预测速度，2)
移除了注意力机制，以避免重复和跳词，以解决健壮性问题。解决方案是使用长度调节器来解决音素和梅尔语谱图序列之间的长度不匹配（具体方法在
3.4.2 节中介绍），便于并行生成。FastSpeech 的
音质与之前的自回归模型差不多。</p>
<p>FastSpeech2 主要从两个方面提升了 FastSpeech：1)
使用真实的梅尔谱图作为训练目标，以替代自回归教师模型中提取出的梅尔谱图作为训练目标。这简化了流程，也避免了蒸馏导致的信息丢失。2)
提供更多的信息，例如音调、时长和能量作为解码器输入，这简化了文本到语音的一对多映射问题。FastSpeech
2 获得了更好的音质，并保持了 FastSpeech
快速、健壮且可控的语音合成优势。FastPitch
通过使用音调信息作为解码器输入来改进 FastSpeech。</p></li>
<li><p>其它声学模型</p>
<p>除了上述模型，还有一些基于 Flow, GAN, VAE, Diffusion
的声学模型，具体见下表（最下面）</p>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211205111232.png"
alt="Pasted image 20211205111232.png" />
<figcaption aria-hidden="true">Pasted image
20211205111232.png</figcaption>
</figure></li>
</ul>
<h3 id="声码器">2.4 声码器</h3>
<p>声码器可分为两类，一类用于组成
SPSS；一类是基于神经网络的声码器。第一类一般包含两部分：声码分析和声码合成，声码分析从声音中提取梅尔倒谱、非周期频谱和基频等声学特征，合成阶段将声学特征合成为音频。</p>
<p>早期的神经网络直接把语言特征作为输入产生音频，后来把梅尔倒谱作为输入。生成较长的音频时，自回归需要很长时间计算，引入
Flow、GAN、VAE、DDPM 模型又改进了这些问题。</p>
<ul>
<li><p>自回归声码器</p>
<p>自回归模型是统计上一种处理时间序列的方法，即使用 x1 至 xt-1 来预测
xt，并假设它们为 x 在时序上呈线性关系，由于它使用 x
预测自已，所以叫自回归。</p>
<p>WaveNet
使用扩展卷积实现自回归来生成音频，与传统的分为分析和合成两步的 SPSS
不同，WaveNet 在声码器部分使用 End-to-end
模型，因为不需要额外的先验知识，WaveNet
的输入是语音学特征，输出是线性谱或梅尔图谱。它虽达到了较好的音质，但用时较长。后续模型对此进行了改进，如
SampleRNN 使用多层 RNN 网络实现无条件生成音频，进而 Char2Wav
实现在声学特征的基本上有条件生成音频。WaveRNN 使用 RNN、双 Softmax
层、权重修剪和缩放等技术减少了计算量。LPC-NET
将传统的数字信号处理引入神经网络，使用线性预测系数计算下一个波形点，以及用轻量级
RNN 计算残差。LPCNet 根据 BFCC 特征产生语音波形……</p></li>
<li><p>基于流的声码器</p>
<p>基于流的模型是一种生成模型。生成模型是给定训练数据，要生成与该数据分布相同的新样本，即用一个概率模型来拟合给定的训练样本。基于流的神经网络分为以下两种类型：</p>
<ul>
<li><p>自回归变换</p>
<p>如逆自回归流 IAF 可以看作是自回归流 (AF) 的对偶公式。AF
的训练是平行的，而生成采样是顺序的。相反，IAF
中的生成采样是并行的，而似然估计的推理是顺序的。并行 WaveNet
利用概率密度蒸馏将 IAF 的有效采样与 AR
建模的有效训练结合起来，但它依赖于复杂的师生训练，并且计算量大。</p></li>
<li><p>二部变换</p>
<p>保证变换是可逆的，二部变换利用仿射耦合层，确保可以从输入可以计算输出，输出也能计算输入。它可达到高音质和更快的速度。</p></li>
<li><p>上述两种变换各有优缺点</p>
<p>自回归变换对数据分布 x 和标准概率分布 z
之间的相关性建模，因而具有更好的表现力，但相对复杂；二部变换相对简单，但需要大量参数；综合二项，WaveFlow
提供了基于似然的模型的统一视图来实现并行预测。</p></li>
</ul></li>
<li><p>基于 GAN 的声码器</p>
<p>生成对抗网络 GAN
常用作生成器，如生成文本、生成声音、生成图片等，它一般包括生成器和鉴别器两部分。一般名字里带
GAN 的 TTS 都使用了生成对对抗网络。</p>
<ul>
<li><p>生成器</p>
<p>大多数 GAN
的声码器使用扩展卷积来增加接受场来模拟波形序列中的长相关性，并用上采样条件信息匹配波形序列的长度。如：选择对条件信息进行一次上采样，然后进行膨胀卷积以保证模型容量。上采样过早地增加了序列长度，导致较大的计算量。因此，一些编码器选择迭代上采样并进行扩展卷积，以避免较低层的过长序列。vocGan
提出了一种多尺度生成器，输出不同尺度的波形序列。HiFi-GaN
通过多感受场融合模块并行处理不同长度的不同图案，在合成效率和样品质量之间进行折衷。</p></li>
<li><p>鉴别器</p>
<p>鉴别器。鉴别器的目的是捕捉波形特征，从而引导生成器更好地生成音频。1)
随机窗口鉴别器（InGaN-TTS）使用多个鉴别器来鉴别波形的不同随机窗口，它以不同的互补方式评估音频，简化全音频的真假判断；2)
多尺度鉴别器（Melgan）使用多个鉴别器来判断不同尺度 (音频下采样)
的音频，每个尺度上的鉴别器可以聚焦于不同频段的特征；3)
多周期鉴别器（HiFi-GaN）利用多个鉴别器鉴别等间距样本，通过观察输入信号在不同周期的不同部分，捕捉到不同的隐含结构。4)
分级鉴别器（vocGAN）对产生的波形从粗粒度到细粒度进行不同分辨率的判别，引导生成器学习低频和高频声学特征与波形的映射关系。</p></li>
<li><p>损失函数</p>
<p>新模型也对损失函数对行了改进，用于提高对抗训练的稳定性和效率，并改善感知音频质量。</p></li>
</ul></li>
<li><p>基于扩散的声码器</p>
<p>DDPM
去噪扩散概率模型的基本思想是用扩散过程和逆过程来表征数据与潜在分布之间的映射关系：在扩散过程中，波形数据样本逐渐加入一些随机噪声，最后变成高斯噪声；在反向过程中，随机高斯噪声逐步去噪为波形数据样本。基于扩散的声码器可以产生非常高音质的语音，但迭代过程时间长，推理速度慢。很多模型都致力于解决这一问题。</p></li>
<li><p>其它声码器</p>
<p>还有其它一些工作，如：在保持语音生成可控的同时实现高语音质量。通过综合实验对几种常见声码器进行评估，研究声码器的鲁棒性等。</p></li>
<li><p>讨论</p>
<p>总结如下：</p>
<ul>
<li>基于自回归 (AR) 相比于其它模型在数学上更简单。</li>
<li>除 AR 之外，所有的生成模型都可以支持并行语音生成。</li>
<li>除 AR 之外，所有的生成模型都能在一定程度上支持潜在的调控。</li>
<li>基于 GAN 的模型不能估计数据样本的似然。</li>
</ul></li>
</ul>
<h3 id="走向完全的-end-to-end-模型">2.5 走向完全的 End-to-end 模型</h3>
<p>End-to-end
端到端的模型输入是字符或音素，输出是音频，它的优点是：需要较人的人工标注和特征提取；2)
避免了流式模型向后传递错误的问题；3) 减小了训练，开发和部署的成本。</p>
<p>它面临的最大挑战是由于模态不同，输入字符和输出音频之间长度无法匹配。比如
20 个单词，对应 100 个音素，生成 80k
长度的音频序列，由于内存限制，难于全部训练，切块训练又难以取得上下文的表征。</p>
<p>为解决这一问题，神经网络 TTS 发展经历了一个从 SPSS 走向 End-to-end
的渐进发展过程，如下图 所示。1)
简化文本分析模块和语言功能，只保留文本归一化和字音素转换，将字符转换成音素，或者直接将字符作为输入去掉整个文本分析模块。2)
简化声学特征，将复杂的声学特征简化为 Mel 谱图。3)
将两个或三个模块替换为单个端到端模型。</p>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211209094239.png"
alt="Pasted image 20211209094239.png" />
<figcaption aria-hidden="true">Pasted image
20211209094239.png</figcaption>
</figure>
<ul>
<li>场景 0：最基本的 SPSS 模型结构，使用了三个基本模块。</li>
<li>场景
1：将文本分析和声学模型合并成一个端到端的模型，从音素生成声学模型生，转给声码器产生音频。</li>
<li>场景 2：WaveNet
第一次从语言学特征直接生成音频输出，可将它看作合并了声学模型和声码器，但它仍需要文本分析模型来生成语言学特征。</li>
<li>场景 3：Tacotron 提出了简化语言特征和声学特征的方案，使用编码器 -
注意力模型 - 解码器模型直接从字符/音素预测线性谱图或梅尔图谱。</li>
<li>场景 4：输入为字符或音素，输出为音频的端到端模型。Char2Wav
从字符生成声学特征，SampleRNN
生成波形，结合这两个模型可用于直接语音合成。类似地，ClariNet
联合直接产生波形的自回归声学模型和非自回归声码器；FastSpeech 2s
直接使用并行结构的文本生成语音，可以极大地提高预测速度；EATS
的并行模型直接从字符/音素生成波形，它利用持续时间内插和软动态时间回绕损耗进行端到端对齐学习。Wave-Taco
tron 在 Taco tron 上构建了一个基于流的解码器，直接产生波形。</li>
</ul>
<h3 id="其它分类方法">2.6 其它分类方法</h3>
<p>除了以上的分类方法，还可以把模型分为：1) 自回归模型和非自回归模型；2)
根据生成模型的方式，可分为： 普通生成模型，流模型，GAN，VAE 以及
diffusion 传播模型；3) 按网络结构可分为
CNN，RNN，自注意力模型和混合模型。</p>
<h2 id="tts-高级主题">3 TTS 高级主题</h2>
<h3 id="背景和分类">3.1 背景和分类</h3>
<p>本章的内容主要讨论一些前沿研究和应用。3.2
部分将讨论对自回归模型的加速以及缩减模型大小；3.3
讨论如何提升合成效果的自然度和易懂，例如：在训练数据较少的情况下，如何有效地训练模型；3.4
讨论加强模型的鲁棒性，如改进丢词重复等问题，以提升模型的易懂性。3.5
讨论如何通过控制模型的风格和韵律以提升模型的表现力；3.6
讨论使用少量数据训练，适配参数，来训练转换目标说话人，以实现高质量的语音适配的应用。</p>
<h3 id="tts-加速">3.2 TTS 加速</h3>
<p>TTS
服务经常部署在云端或者在嵌入式系统中支行，需要较快的合成速度。早期的模型对于长文本合成速度较慢，为解决这一问题，出现的技术方案包含：1)
使用非自回归模型产生梅尔图谱以及并行化生成音频；2)
轻量和有效的模型结构；3) 利用领域知识加快语音合成，具体方法如下：</p>
<p><strong>并行生成器</strong></p>
<p>各个模型的时间复杂度如下表所示</p>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211213095348.png"
alt="Pasted image 20211213095348.png" />
<figcaption aria-hidden="true">Pasted image
20211213095348.png</figcaption>
</figure>
<p><strong>模型减重</strong></p>
<p>非自回归模型虽然加快了训练和预测的速度，但并没有简化模型参数和训练量，对于嵌入设备模型减重也非常重要，与此相关的工作主要集中在：修剪、量化、知识提炼和神经结构搜索。</p>
<p><strong>使用领域知识加速</strong></p>
<p>加入领域知识可加速预测，具体方法如：</p>
<p>线性预测：将数字信号处理与神经网络相结合，采用线性预测系数计算下一个波形，采用轻量级模型预测残差值，加快了自回归波形生成的推理速度。</p>
<p>多频带/子频带建模：把音频拆成多个子频带，用于加快声码器的速度。</p>
<p>除此以外，还有利用充分聚束和比特聚束减少计算复杂度；流合成即不等待全句只对现在
token
合成加快预测速度；用简单结构模拟快速傅里叶变换；用帧分割和交叉递减，并行合成波形的某些部分，然后将合成的波形串联在一起，以确保低端设备上的快速合成等方法。</p>
<h3 id="使用少量资源训练模型">3.3 使用少量资源训练模型</h3>
<p>一般情况下，训练模型都需要大量高品质的文本和音频数据，但世界上的很多语言没有足量数据，所以商业软件一般只支持十几种常用语言。对于小语种合成商业产值不大，但很有社会意义。为实现这一目标，产生了以下技术。</p>
<p><strong>自监督训练</strong></p>
<p>文本和音频对很难收集，但收集未配对的相对容易。自监督训练被用于提升语音的可懂度和语音的生成能力。比如使用预训练的
BERT
模型作为编码器，使用预训练的自回归梅尔图谱生成器作为解码器，建立语音转换任务联合训练，此外，可以将语音量化为离散的
token 序列，以与音素或字符序列相似。以此方式预训练 TTS
模型，然后在少数真正配对的文本和语音数据上微调该 TTS 模型。</p>
<p><strong>跨语言转换</strong></p>
<p>由于人类的语音使用类似的发声器官，读音和语义结构，丰富的语言训练出的模型，可以映射到小语种模型中。由于音素略有差异，所以需要对
Embedding 层进行一些处理；采用国际音标 (IPA)
或字节表示法可以支持多语言的任意文本。此外，在进行跨语言迁移时也可以考虑到了语言的相似性。</p>
<p><strong>转换发音者</strong></p>
<p>当某个说话人的语音数据有限时，可以利用来自其他说话人的数据来提高该说话人的合成质量。具本方法是通过语音转换将其他说话者的语音转换为该目标语音以增加训练数据，或者通过语音适配或语音克隆使针对其他语音训练的
TTS 模型适应该目标语音，此问题将在在 3.6 节进一步讨论。</p>
<p><strong>语音链反向转换</strong></p>
<p>语音合成和语音识别是对偶的两组应用，可以利用它们之前的关系互相改善。</p>
<p><strong>利用低品质数据</strong></p>
<p>在网络上存在一些低质量的文本音频对，从中可以挖掘并改进 TTS
模型质量，比如利用它们来降噪、去纠缠等。</p>
<h3 id="tts-鲁棒性">3.4 TTS 鲁棒性</h3>
<p>影响 TTS
鲁棒性的通常是声学模型中经常会出现跳词、重复、注意力崩溃等等问题。有以下两个原因：</p>
<ul>
<li>难以对齐梅尔图图谱和字符音素。有两种解决方法，一种是改善注意力模型；另一种是使用时长预测代替注意力模型。</li>
<li>自回归生成中的偏差爆炸和误差传播。有两种解决方法，一种是改进自回归模型，另一种是用非自回归取代自回归模型。</li>
</ul>
<p>声码器不会面临上述问题，因为声学特征和波形已经按帧对齐。</p>
<h4 id="提升注意力机制">3.4.1 提升注意力机制</h4>
<p>自回归的声码器的问题常常是由于编码器 - 注意力 -
解码器结构中注意力对齐（文本和音频特征对齐）问题引起的，下面是核心问题：</p>
<ul>
<li>Local：一个字符可对应多个音频帧，而每帧只对应一个字符；可用于解决注意力崩溃问题问题。</li>
<li>Monotonic（单调性）：字符有先后顺序，如果字符 A 在 B 前，则输出音频
A 也在 B 前，可用于解决重复问题。</li>
<li>Complete（完备性）：每个字符至少对应一帧，可用于解决丢音问题。</li>
</ul>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211215100544.png"
alt="Pasted image 20211215100544.png" />
<figcaption aria-hidden="true">Pasted image
20211215100544.png</figcaption>
</figure>
<p>具体方案如下：</p>
<ul>
<li><p>Content-based attention（基于内容的注意力）</p>
<p>早期的注意模型是基于内容的，注意力的分布取决于编码器和解码器之间隐藏层的匹配度。Attention
模型一开始用于解决翻译等问题，翻译中源和目标中的词可按含义来对义，但对于语音合成和语音识别问题的对齐则比较困难，需要注意上述的三个核心问题。</p></li>
<li><p>Location-based attention（基于位置的注意力）</p>
<p>根据位置对齐文本和音频特征，使用它可以保证单调性。</p></li>
<li><p>Content/Location-based hybrid
attention（基于内容和位置的混合注意力）</p>
<p>结合了上下文和位置对齐两种方法，使用前一个注意力对齐来计算当前注意力对齐，也用于解决单调性问题。</p></li>
<li><p>Monotonic attention（单高性注意力）</p>
<p>在对齐时参考了位置单调增加的原理，从而解决了丢音和重复的问题，为保证完备性，He
et
al.又提出了步进单调注意力，保证对齐注意力位置每次只前进一步，从而保证不跳过任何一个单元。</p></li>
<li><p>Windowing or off-diagonal penalty（加窗和非对角线处罚）</p>
<p>由于单调可知，输入和输出呈对角线关系，因此，提取了将注意力限定在子窗口中，从而降低了学习灵活性和难度；另外，通过构造掩码，使用损失函数惩罚的方式，鼓励注意力分布在对角线附近区域内（band），</p></li>
<li><p>Enhancing encoder-decoder connection（提升编解码器的连接）</p>
<p>输出帧之间有很强的相关性，解码器常常更多的考虑前其之前帧的数据，从而忽略了编码器的输入。因此很多工作在编解码器之间建立更强的链接，从而改进注意力的对齐能力。比如：在每个时间步产生多帧预测；丢弃之前的信息，以减少对后面预测的影响；提高编解码之间位置的关联性；鼓励输出的梅尔图谱包含更多文本信息。</p></li>
<li><p>Positional attention（位置注意力）</p>
<p>有一些非自回归模型，使用位置作为 query，加入 key,value 的计算（详见
attention 模型）。</p></li>
</ul>
<h4 id="用长度预测取代注意力">3.4.2 用长度预测取代注意力</h4>
<p>上述的注意力模型改进无法解决所有问题，一些人试图用预测各字符输出音频的长度来解决问题，以替代注意力模型，这有点像之前
SPSS
中的长度预测。一般有两种做法：第一种是使用扩展工具联合训练，给长度打标签；第二种是使用真实时长代入训练
End-to-end 模型，在预测时预测出长度。</p>
<ul>
<li><p>外部对齐</p>
<p>引用外部工具实现对齐，主要包括以下几种：1)
从编解码注意力模型中获取持续时间标签；2) 基于语音识别的 CTC
对齐音素和梅尔图谱输出；3)
隐马尔可夫对齐基于蒙特利尔强制对齐提取时间长度。</p></li>
<li><p>内部对齐</p>
<p>Align 使用动态规划法通过多阶段训练学习文本和梅尔图谱之前的关系；JDI-T
借鉴 FastSpeech 从自回归教师模型中提取时长，但不需要两阶段训练；Glow-TTS
单调对齐搜索来提取持续时间；EATS 利用插值和 DTW
优化端到端时间预测。</p></li>
<li><p>对 End-to-end 优化</p>
<p>典型的时间预测方法用内部或外部的对齐工具提取时间用于训练；用预测的时长用于整个模型的预测。利用梅尔图谱的损失函数来优化模型。</p></li>
<li><p>End-to-end 优化</p>
<p>EATS 使用内部模块预测时长，并借助时长插值和软 DTW
损失对时长进行端到端的优化。非注意模型 Tacotron
提出了半监督学习方法，如果没有持续时间标签可用，则预测的时长可以用于上采样。</p></li>
</ul>
<h4 id="提升自回归模型效果">3.4.3 提升自回归模型效果</h4>
<p>自回归模型常常遇到偏差爆炸误差传播问题，偏差爆炸是由于在训练过程中，使用上一步的输出作为下一步的输入，而预测时上一步的输出也是预测出来的。训练和预测的差异导致错误在预测时错误不断向后传播，偏差在短时间内很快积累起来。</p>
<p>目前研究了不同的方法来缓解上述问题。Guo
等利用教授强迫来缓解实际数据和预测数据的不同分布的差异。刘等进行师生蒸馏方法，教师接受教师强迫模式的训练，学生之先前预测的值作为输入，优化以减小教师和学生模型之间隐藏状态的距离。生成的梅尔谱图序列的右侧通常比左侧差，因此利用从左到右和从右到左的生成来进行数据扩充和规范化；Vainer
and Dušek
提出了数据扩充的方法，将高斯噪声加入图谱来模拟预测误差，并通过随机替换几个帧来降低输入谱的质量，以鼓励模型依赖使用更远的帧生成。</p>
<h4 id="用非自回归替换自回归">3.4.4 用非自回归替换自回归</h4>
<p>非自回归模型可划分为两类：ParaNet 和 Flow-TTS
使用上文中提到的位置注意力（positional attention）对齐文本的语音;
FastSpeech 和 EATS [69] 使用时长预测解决文本和语音序列之间错位的问题。AR
和 Attention 有以下组合：</p>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211216080508.png"
alt="Pasted image 20211216080508.png" />
<figcaption aria-hidden="true">Pasted image
20211216080508.png</figcaption>
</figure>
<h3 id="tts-表现力">3.5 TTS 表现力</h3>
<p>语音的自然度很大程度上依赖表现力，与此相关的研究包括：内容、音色、韵律、风格、情感等方面的建模、解缠、控制和传递等。</p>
<p>语音表现力中一个关键问题是一对多映射，单一文本对应多个语音参数，如时长，音高，音量，风格，情感等。如果只使用
L1
损失函数且没有丰富的输入信息，将导致过于平滑的梅尔图谱预测，比如只对数据库里的单音素建模，将导致低音质和低表现力。因此，需要提供更多样的信息做为建模的输入。另外，使用更多多信息作为输入后，可实现：1)
通过控制参数控制合成效果；2) 转换语音风格；3)
为实现细力度的控制，需要分解内容、韵律、音色和噪音等各个因素。</p>
<h4 id="参数信息分类">3.5.1 参数信息分类</h4>
<ul>
<li><p>文本信息</p>
<p>需要表达的内容，如文本或者音素，一些方法可以通过词嵌入或文本预训练的方式来提高合成质量和表现力。</p></li>
<li><p>发音人音色</p>
<p>发音人相关特征，支持多发声者的 TTS
系统需要对声音人的特征建模。</p></li>
<li><p>韵律、风格和情感</p>
<p>韵律、风格和情感是提升表现力的主要方法，包含了包含语调、重音和节奏以及如何说出文本。</p></li>
<li><p>录音设备和环境噪声</p>
<p>设备和环境是语音的通道，它与上述三点不相关，但也影响了音质，这方面的研究围绕合成中的分解，控制，降噪。</p></li>
</ul>
<h4 id="参数信息建模">3.5.2 参数信息建模</h4>
<p>与表现力相关的参数包括：</p>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020211216083342.png"
alt="Pasted image 20211216083342.png" />
<figcaption aria-hidden="true">Pasted image
20211216083342.png</figcaption>
</figure>
<p><strong>信息类型</strong></p>
<p>信息类型可分为外显和内隐两种，外显型可以明确打标签；内隐型只能通过计算获取其参数。</p>
<p>对于外显型，我们可以直接使用它作为模型输入，获取它的渠道包含：1)
获取语言 ID，声音者 ID，韵律的标签数据，比如韵律数据的标注方法如
ToBI，AutoBI，Tilt，SLAM 等；2) 从音频中提取音高、能量，时长等。</p>
<p>除了外显型数据还包含一些更细粒度的参数，可通过模型从数据中提取，典型的建模方法包括：</p>
<ul>
<li><p>参考编码</p>
<p>Kerry-Ryan
等人将韵律定义为去除由于文本内容后语音信号中剩余的变化，音色、通道效果和模型韵律不需要编码器来标注。它从参考音频中提取韵律，作为解码器的输入。在训练过程中，使用真实参考音频，在推理过程中，使用另一参考音频来合成具有相似韵律的语音。Wang
从参考音频中提取嵌入内容，并将其用作查询来参与 (通过基于 Q/K/V 的注意力)
风格标记库，并且将关注结果用作用于模型的韵律条件。从而增加 TTS
模型学习不同类型样式的能力和变化性，使数据集中不同数据样本之间的知识共享成为可能。风格符号库中的每个符号可以学习不同的韵律表征，例如不同的语速和情绪。在推理过程中，利用参照音和提取的韵律，简单地选择风格符号来合成语音。</p></li>
<li><p>变量自动编码</p>
<p>张等人利用 VAE
对潜在空间中的更多信息进行建模，利用高斯先验作为正则化，实现对合成风格的表现力建模和控制。一些研究还利用
VAE 框架更好地对表达合成的更多信息进行建模。</p></li>
<li><p>对抗生成模型</p>
<p>利用生成对抗模型对隐变量建模，学习更多信息，可优化一对多的映射问题，对抗预测过于平滑的问题，能够更好地模拟多模态分布。</p></li>
<li><p>文本预训练</p>
<p>使用预测训练的模型利用词嵌入和参数提升模型的表现力。</p></li>
</ul>
<p><strong>信息粒度</strong></p>
<p>从粗到细分成六个粒度等级：1) 语音和发音者等级；2)
段落等级（由短语和句子构成）；3)
短语等级，提取单个隐藏向量来表示该发音的音质/风格/韵律；4)
词/音节等别，它针对发音级别，但无法覆盖的细粒度风格/韵律信息；5)
字符/音素等级，包含持续时间、音高或韵律信息；6) 帧等级。</p>
<p>此外，还有使用多个不同粒度的层次结构建模，以提升表现力。Suni
等人论证了韵律层次结构在口语中的内在存在。Kenter
等人从框架和音素级别到音节级别预测韵律特征，并与单词和句子级别的特征串联。Hono
等人利用多粒度的 VAE
来获得不同的时间分辨率潜变量，并从较粗级别的潜变量采样较细级别的潜在变量。Sun
等人使用 VAE
对音素和单词级别的差异信息进行建模，并将它们组合在一起输入解码器。Chien
和 Lee
对韵律预测进行了研究，提出了从词到音级的层次结构来改进韵律预测。</p>
<h4 id="分解控制和转换">3.5.3 分解、控制和转换</h4>
<ul>
<li><p>使用对抗训练分解</p>
<p>当风格和韵律信息纠缠在一起时，需要通过训练将它们分离，以加强合成模型的表现力，以及控制这些参数。Ma
等人利用对抗性、协作的方法，增强内容的解缠能力和可控性。Hu
等人通过对抗训练利用 VAE
框架，将噪音从说话人信息中分离出来。钱等人使用三个瓶颈重构来解开节奏、音高、内容和音色。Zhang
等人提出通过帧级噪声建模和对抗性训练来分离说话人的噪声。</p></li>
<li><p>使用循环一致性/反馈损失来控制风格</p></li>
</ul>
<p>当提供风格标签等信息作为输入时，TTS
模型可合成具有相应风格的语音。为了增强 TTS
模型的可控性，一些工作提出使用周期一致性或反馈损失来鼓励合成语音在输入中包含差异信息。</p>
<ul>
<li>利用半监督学习提升可控性</li>
</ul>
<p>如果对音高、长度、能量、韵律、情感、发音人、噪音等属性都有标注，那到通过设置这些属性，很容易控制合成。但在没有这些标注，或只有部分标注的情况下，使用半监督学习方法，也可以实现分离这些特征。</p>
<ul>
<li>通过控制差异信息实现变换</li>
</ul>
<p>通过差异信息改变风格，如果有对差异的标注，对语音数据训练，从而根据标签在合成时转换风格。在没有标注的情况下，还能从训练中提取差异信息。像音高、长度、能量都可以从数据中提取，另外，还能提取一些不易描述的潜在信息。</p>
<h3 id="适配-tts">3.6 适配 TTS</h3>
<p>使用适配 TTS
技术，可以为任何发音人合成语音，常被用于配音、声音克隆、自定义声音，是非常热门的研究领域。包含之前统计参数合成、以及最近的一些语音克隆挑战比赛。通常源模型是支持多发音人的
TTS 模型，通过少量数据适配，训练出针对新发音人的模型。</p>
<p>通常将其分成通用适配（提升通用模型）和有效适配（），如下图所示：</p>
<figure>
<img src="/support/attachments_2022/Pasted%20image%2020220115143234.png"
alt="Pasted image 20220115143234.png" />
<figcaption aria-hidden="true">Pasted image
20220115143234.png</figcaption>
</figure>
<h4 id="通用适配">3.6.1 通用适配</h4>
<p><strong>通用的源模型</strong></p>
<p>目标是为了提升源模型。一般情况下在训练过程中，没有包含韵律、单色、录音环境的标注，因此训练出的模型容易对训练集过拟合，缺乏泛化能力。于是使用在训练时将必要的声学特征作为输入，将记忆力变为泛化力；以及使用多样性的数据训练的方法。</p>
<p><strong>交叉领域适配</strong></p>
<p>实现了在不同语言之间转换，如使用英文发音者实现中文普通语的语音合成。AdaSpeech
设计了对不同录设备、环境噪声、噪音、语速、音色等声学条件的建模方法。</p>
<h4 id="有效适配">3.6.2 有效适配</h4>
<p>一般情况下，更多的数据使用模型达到更好的语音效果，但也造成更大的花费。利用适参数，通过对整个模型或部分模型的精调（fine-tune），有效适配的目标是尽可能少的数据和参数达到较高的适配效果。基本分为以下四类：</p>
<ul>
<li>更少数据适配</li>
</ul>
<p>只使用少量文字语音数据精调模型，从几钟到几秒钟不等，甚至是小于二十个句子。</p>
<ul>
<li>更小参数适配</li>
</ul>
<p>在需要适配多个发音者的情况，需要让语音占内存较小的情况下达到较高音质。例如
AdaSpeech
提出了对条件层归一化生成参数，只需要精调该层参数就可以达到较好的适配效果。</p>
<ul>
<li>未转录的数据适配</li>
</ul>
<p>在很多场景之中，只有语音数据，比如在线会议，AdaSpeech2
利用这些语音数据实现重建和潜在的对齐，Inoue 等人提出使用 ASR
方式识别语音数据，然后使用转录的数据对进行语音适配。</p>
<ul>
<li>zero-shot 适配</li>
</ul>
<p>对没有目标发音人语音数据的情况下，利用参数来实现适配，这种方式在目标发音人和源数据发音人差异较大时效果不好。</p>
<h2 id="资源">4. 资源</h2>
<p>此处总结了一些 TTS 资源，包含开源项目、教程、比赛和语料库。</p>
<h2 id="未来方向">5. 未来方向</h2>
<p><strong>高质量的语音合成</strong></p>
<p>高质量的语音是语音合成的目标，它涉及清晰度、自然度、表现力、韵律、风络、情况、健壮性、可控等方面。</p>
<ul>
<li>能力更强的语音生成模型</li>
<li>学习更好的表征，以提升模型效果</li>
<li>合成的健壮性，解决重音、跳音、长语音，提升泛化性以适应不同领域</li>
<li>表现力/控制/转移，让模型捕捉更多内在信息，以实现控制和转移</li>
<li>与人更相似，在情绪化、风格、自然度方面仍有待提升</li>
</ul>
<p><strong>有效的语音全成</strong></p>
<p>减少资源占用包含减少收集和标注数据，训练模型和模型服务。</p>
<ul>
<li>精减数据，利用无监督或半监督学习和转移方法，对缺少数据的语音建模。</li>
<li>精减参数，神经网络针对高质量的合成常常有数以千万计的模型参数，但在移动端，则需要限制内存和功耗，设计轻量级的模型是重要的应用场景。</li>
<li>节能，训练和提供高品质的服务，提升资源利用效率。</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><p>语音合成（TTS) 论文优选：Cross-lingual<br />
<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/280705416">https://zhuanlan.zhihu.com/p/280705416</a></p></li>
<li><p>AI 语音：语音合成，语音识别等语音技术（知乎专栏） <a
target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1306669801105391616">https://www.zhihu.com/column/c_1306669801105391616</a></p></li>
<li><p>语音合成论文优选：语音合成综述（2021） <a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/395767716">https://zhuanlan.zhihu.com/p/395767716</a></p></li>
<li><p>【论文学习】《A Survey on Neural Speech Synthesis》 <a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42721167/article/details/118684294">https://blog.csdn.net/weixin_42721167/article/details/118684294</a></p></li>
<li><p>《A Survey on Neural Speech Synthesis》（63 页，References 400
多篇） <a
target="_blank" rel="noopener" href="https://arxiv.org/pdf/2106.15561v1.pdf">https://arxiv.org/pdf/2106.15561v1.pdf</a></p></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://xyan666.com">Yan.xie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://xyan666.com/posts/62410/">http://xyan666.com/posts/62410/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E9%9F%B3/">语音</a></div><div class="post_share"><div class="social-share" data-image="/img/blog_logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1755922682/" title="机器学习_条件随机场CRF"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">机器学习_条件随机场CRF</div></div></a></div><div class="next-post pull-right"><a href="/posts/22246/" title="MYSQL_数据库大太的解决方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MYSQL_数据库大太的解决方案</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/2559268045/" title="论文阅读_代码生成_CODEFUSE"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="title">论文阅读_代码生成_CODEFUSE</div></div></a></div><div><a href="/posts/4128897364/" title="RepoCoder：通过迭代检索和生成实现存储库级代码完成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-05</div><div class="title">RepoCoder：通过迭代检索和生成实现存储库级代码完成</div></div></a></div><div><a href="/posts/3483543182/" title="论文阅读_代码生成模型_CodeGeeX"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="title">论文阅读_代码生成模型_CodeGeeX</div></div></a></div><div><a href="/posts/1301849651/" title="论文阅读_代码生成模型_CodeLlama"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="title">论文阅读_代码生成模型_CodeLlama</div></div></a></div><div><a href="/posts/2354085843/" title="论文阅读_大模型优化_YOCO架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">论文阅读_大模型优化_YOCO架构</div></div></a></div><div><a href="/posts/40002/" title="论文阅读_关系表征的在线学习DeepWalk"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-04</div><div class="title">论文阅读_关系表征的在线学习DeepWalk</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/blog_logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yan.xie</div><div class="author-info__description">顺流而下还是逆流而上？</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">864</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">182</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">基本信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%85%E8%AF%BB%E4%BD%93%E4%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">阅读体会</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">3.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.</span> <span class="toc-text">1. 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tts-%E5%8E%86%E5%8F%B2"><span class="toc-number">4.1.</span> <span class="toc-text">1.1 TTS 历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">1.2 文章组织方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">5.</span> <span class="toc-text">2. 主要组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">2.1 主要分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">2.2 文本分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">2.3 声学模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spss-%E4%B8%AD%E7%9A%84%E5%A3%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">2.3.1 SPSS 中的声学模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#end-to-end-%E7%9A%84%E5%A3%B0%E6%95%B0%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.3.2 End-to-end 的声数模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E7%A0%81%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">2.4 声码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B0%E5%90%91%E5%AE%8C%E5%85%A8%E7%9A%84-end-to-end-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">2.5 走向完全的 End-to-end 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">2.6 其它分类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tts-%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">3 TTS 高级主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">3.1 背景和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tts-%E5%8A%A0%E9%80%9F"><span class="toc-number">6.2.</span> <span class="toc-text">3.2 TTS 加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B0%91%E9%87%8F%E8%B5%84%E6%BA%90%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">3.3 使用少量资源训练模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tts-%E9%B2%81%E6%A3%92%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">3.4 TTS 鲁棒性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8D%87%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">6.4.1.</span> <span class="toc-text">3.4.1 提升注意力机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%95%BF%E5%BA%A6%E9%A2%84%E6%B5%8B%E5%8F%96%E4%BB%A3%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="toc-number">6.4.2.</span> <span class="toc-text">3.4.2 用长度预测取代注意力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8D%87%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E6%95%88%E6%9E%9C"><span class="toc-number">6.4.3.</span> <span class="toc-text">3.4.3 提升自回归模型效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%9D%9E%E8%87%AA%E5%9B%9E%E5%BD%92%E6%9B%BF%E6%8D%A2%E8%87%AA%E5%9B%9E%E5%BD%92"><span class="toc-number">6.4.4.</span> <span class="toc-text">3.4.4 用非自回归替换自回归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tts-%E8%A1%A8%E7%8E%B0%E5%8A%9B"><span class="toc-number">6.5.</span> <span class="toc-text">3.5 TTS 表现力</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF%E5%88%86%E7%B1%BB"><span class="toc-number">6.5.1.</span> <span class="toc-text">3.5.1 参数信息分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF%E5%BB%BA%E6%A8%A1"><span class="toc-number">6.5.2.</span> <span class="toc-text">3.5.2 参数信息建模</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.5.3.</span> <span class="toc-text">3.5.3 分解、控制和转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D-tts"><span class="toc-number">6.6.</span> <span class="toc-text">3.6 适配 TTS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E9%80%82%E9%85%8D"><span class="toc-number">6.6.1.</span> <span class="toc-text">3.6.1 通用适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E9%80%82%E9%85%8D"><span class="toc-number">6.6.2.</span> <span class="toc-text">3.6.2 有效适配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90"><span class="toc-number">7.</span> <span class="toc-text">4. 资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91"><span class="toc-number">8.</span> <span class="toc-text">5. 未来方向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2539455493/" title="AI在股票决策中的应用_开源项目XYStock">AI在股票决策中的应用_开源项目XYStock</a><time datetime="2025-09-01T00:00:00.000Z" title="Created 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/652178159/" title="250811_对谈_内向意义和外向意义">250811_对谈_内向意义和外向意义</a><time datetime="2025-09-01T00:00:00.000Z" title="Created 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1404173137/" title="论文阅读_两阶段的股票价格预测">论文阅读_两阶段的股票价格预测</a><time datetime="2025-09-01T00:00:00.000Z" title="Created 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/123182612/" title="论文阅读_大模型情绪分析预测趋势">论文阅读_大模型情绪分析预测趋势</a><time datetime="2025-09-01T00:00:00.000Z" title="Created 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/769430095/" title="股票_相关知识">股票_相关知识</a><time datetime="2025-09-01T00:00:00.000Z" title="Created 2025-09-01 00:00:00">2025-09-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Yan.xie</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></br>
<img class="img-circle profile-img" src="/img/beian.png" alt="">
<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802043346">京公网安备11010802043346号</a>
</br>
<a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">京ICP备2023029600号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>